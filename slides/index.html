<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Concurrent - Distributed task framework</title>

		<meta name="description" content="Distributed task system based on ZeroMQ and a trac [by Edgewall] like component architecture.">
		<meta name="author" content="Moritz Wundke">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/moss.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>Concurrent</h1>
					<h3>Distributed task system in Python</h3>
					<p>
						<small>Created by <a href="http://www.moritzwundke.se">Moritz Wundke</a></small>
					</p>
				</section>

				<section>

					<section>
						<h2>Introduction</h2>
						<p>
							Concurrent aims to be a different type of task distribution system compared to what MPI like system do. It adds a simple but powerful application abstraction layer to distribute the logic of an entire application onto a swarm of clusters holding similarities with volunteer computing systems.
						</p>
						<aside class="notes">
						</aside>
					</section>

					<section>
						<h2>Introduction cont'd</h2>
						<p>
							Traditional task distributed systems will just perform simple tasks onto the distributed system and wait for results. Concurrent goes one step further by letting the tasks and the application decide what to do. The programming paradigm is then totally async without any waits for results and based on notifications once a computation has been performed.
						</p>
						<aside class="notes">
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Why?</h2>
						<ul>
							<li>Flexible</li>
							<li>Stable</li>
							<li>Rapid development</li>
							<li>Python</li>
						</ul>
					</section>

					<section>
						<h2>Why? - Flexible</h2>
						<ul>
							<li>Keystone for every framework</li>
							<li>Must be reused in many typed of projects</li>
							<li>Easy to integrate in existing code</li>
						</ul>
					</section>

					<section>
						<h2>Why? - Stable</h2>
						<ul>
							<li>Fault tolerrance</li>
							<li>Consistency</li>
							<li>We sacrify availability</li>
						</ul>
						<aside class="notes">
							Talk about the PAC theorem, we have chosen to sacrify availability
						</aside>
					</section>

					<section>
						<h2>Why? - Rapid development</h2>
						<ul>
							<li>Fast prototyping</li>
							<li>Python is fast to write, very fast!</li>
							<li>Deliver soon and often principle</li>
						</ul>
						<aside class="notes">
							Note on agile development
						</aside>
					</section>

					<section>
						<h2>Why? - Python</h2>
						<ul>
							<li>Huge community</li>
							<li>Used in scientific computation</li>
							<li>Deliver soon and often principle</li>
							<li>Imperative and functional</li>
							<li>Very organized</li>
							<li>Cross-Platform</li>
							<li>Object serialization through pickle, thus dangerous if not used properly!</li>
							<li>Drawback: pure python performance</li>
						</ul>
						<aside class="notes">
							Note on agile development
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>The Dark Side</h2>
						<ul>
							<li>Pure python performance</li>
							<ul>
								<li>Cython</li>
								<li>Native</li>
							</ul>
							<li>No real multithread</li>
							<ul>
								<li>The GIL issue</li>
								<li>Releasing the GIL manually</li>
								<li>multiprocessing (fork)</li>
							</ul>
							<li>Rapid development</li>
							<li>Python</li>
						</ul>
					</section>

					<section>
						<h2>The Dark Side - Perf</h2>
						<ul>
							<li>Python is slow, thats a fact</li>
							<li>But we can boost it using natives</li>
							<ul>
								<li>Cython: Static C compiler combining both python flexibility and C performance</li>
								<li>Native c module: Create python modules directly in C</li>
							</ul>
						</ul>
					</section>

					<section>
						<h2>The Dark Side - GIL</h2>
						<ul>
							<li>Global Interpreter Lock: Only one line or python object access at a time per process</li>
							<li>We can release the GIL using natives like Cython or directly in a native module</li>
							<li>We can also use processes instead of threads, while adding the need for IPC mechanisms</li>
							<li>Shared vs Distributed memory / Threads vs Processes</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Concurrent</h2>
						<ul>
							<li>Distrubuted task execution framework which tries to solve the GIL issue</li>
							<li>Does not use threads when executing processes</li>
							<li>Features different ways to implement IPC calls</li>
							<li>All nodes in the system communicate through RPC calls or using HTTP or low-level TCP</li>
							<li>Integrated Cython for performance tweaking</li>
						</ul>
					</section>

					<section>
						<h2>Other frame works</h2>
						<ul>
							<li><b>Dispy:</b> Fork based system, not applciation or cloud oriented as concurrent, problems with TCP congestions</li>
							<li><b>ParallelPython:</b>  Thread based based system, not applciation or cloud oriented as concurrent, problems with TCP congestions</li>
							<li><b>Superpy:</b> Similar to concurrent but does not feature a high-performance transport layer. Only for windows.</li>
							<li><a href="https://wiki.python.org/moin/ParallelProcessing">More libraries</a></li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Architecture</h2>
						
						<p>
							Concurrent is build upon a flexible plugable component framework. Most of the framework is plugable in few steps and can be tweaked isntalling plugins.
						</p>
						<p>
							Applications themselfs are plugins that are then load on the environment and executed
						</p>
					</section>

					<section>
						<h2>Components</h2>

						<p><img src="images/Concurrent_Components.png"></p>
						
						<p>
							<i>Component</i>s are singleton instances per <i>ComponentMananer</i>. They implement the functionality of a given <i>Interface</i> and talk to each other through an ExtensionPoint
						</p>
					</section>

					<section>
						<h2>Components cont'd</h2>

						<p><img src="images/Concurrent_Components_Example.png"></p>
						
						<p>
							Example setting of <i>Component</i>s linked together with <i>ExtensionPoint</i>s
						</p>
					</section>

					<section>
						<h2>Components cont'd</h2>

						<p><img src="images/configs.png"></p>
						
						<p>
							Configuration system allows us to configure <i>ExtensionPoint</i>s via config files.
						</p>
					</section>

					<section>
						<h2>Nodes</h2>
						
						<p>Our distributed system is based on a 3 node setup, while more classes are involved for flexibility</p>
						<ul>
							<li><b>MasterNode:</b> Our main master (or a layer within a multi-master setup). Distributed the workload and maintains the distributed system.</li>
							<li><b>SlaveNode:</b> A slave node is connected to a master (or a set of masters in a multi-master setup). Executes the workload a master sends to this node or requests work from it.</li>
							<li><b>ApplicationNode:</b> An application using the framework sending work to it. Usually connected to a single master (or multiple master on a multi-master setup).</li>
						</ul>
					</section>

					<section>
						<h2>Nodes cont'd</h2>
						
						<p><img src="images/Concurrent_Nodes.png"></p>
					</section>

					<section>
						<h2>Task Scheduling</h2>
						
						<p>
							Concurrent comes with two task scheduling policies, one optmized for heterogeneous systems and another for homogeneous systems.
						</p>
						<ul>
							<li><b>Generic:</b> For heterogeneous systems. Sends work to the best slave for the given work. Comes with slightly more overhead</li>
							<li><b>ZMQ:</b> ZMQ push/pull scheduling, for homogenous systems. Slave requests task from a global socket. Less overhead but prone to stalls if heardware is not the same on all slaves.</li>
						</ul>
					</section>

					<section>
						<h2>Task Scheduling cont'd</h2>

						<p><img src="images/Concurrent_Tasks.png"></p>
					</section>

					<section>
						<h2>Task Scheduling cont'd</h2>

						<p>From previous slide</p>
						
						<p>
							Generic scheduling execution flow. A <i>GenericTaskScheduler</i> uses a <i>GenericTaskScheduleStrategy</i> to send work to a <i>GenericTaskManager</i> of the taregt slave.
						</p>
					</section>

					<section>
						<h2>Task Scheduling cont'd</h2>

						<p><img src="images/Concurrent_ZMQScheduler.png"></p>
					</section>

					<section>
						<h2>Task Scheduling cont'd</h2>

						<p>From previous slide</p>

						<p>
							ZMQ push/pull scheduling execution flow. A <i>ZMQTaskScheduler</i> pushes work onto a global work socket. The <i>ZMQTaskManager</i>s of the slaves pull that work from it and perform the processing. The result is then pushed back to the master node.
						</p>
					</section>

					<section>
						<h2>Transport</h2>
						
						<p>Concurrent comes with a complex transport module that features TCP and ZMQ sockets clients, servers and proxies.</p>
						<ul>
							<li><b>TCPServer:</b> multithreaded TCP socket server.</li>
							<li><b>TCPServerZMQ:</b> multithreaded ZMQ server using a imited number of pooled workers.</li>
							<li><b>TCPClient:</b> TCP client used to establish connection to a <i>TCPSocket</i>.</li>
							<li><b>Proxies:</b> proxies are used to implement RPC like calling mechanisms between servers and clients.</li>
							<li><b>TCPHandler:</b> containter andling registrartion of RPC methods.</li>
						</ul>
					</section>

					<section>
						<h2>Transport cont'd</h2>

						<p><img src="images/Transport.png"></p>
					</section>

					<section>
						<h2>Transport cont'd</h2>
						
						<p>
							Registering RPC methods is straightforward in concurrent. Just register a method with the given server or client instance.
						</p>
    					<pre><code data-trim>
@jsonremote(self.api_service_v1)
def register_slave(request, node_id, port, data):
    self.stats.add_avg('register_slave')
    return self.register_node(node_id, web.ctx['ip'], port, data, NodeType.slave)

@tcpremote(self.zmq_server, name='register_slave')
def register_slave_tcp(handler, request, node_id):
    self.stats.add_avg('register_slave_tcp')
    return self.register_node_tcp(handler, request, node_id, NodeType.slave)</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Main features</h2>

						<ul>
							<li><b>No-GIL:</b> no GIL on our tasks.</li>
							<li><b>Balancing:</b> tasks are balanced using load balancing.</li>
							<li><b>Nice to TCP:</b> internal buffering to avoid TCP congestions.</li>
							<li><b>Delployment:</b> easy to deploy application onto concurrent.</li>
							<li><b>Fast development:</b> easy application framework to build concurrent applciaitons that work on a high number of machines in minutes.</li>
							<li><b>Batching:</b> task batching to simple task schemas.</li>
							<li><b>TaskSystem approach:</b> autonomous systems control tasks. Easy to implement concurrency in an organize fashion.</li>
							<li><b>Plugable:</b> all components are plugable, felxible development and adding new features.</li>
							<li><b>API:</b> RESTful JSON API and TCP/ZMQ API in the same fashion. From the programmer calling a high-performance TCP method is the same as colling a web-service</li>
						</ul>
					</section>

					<section>
						<h2>Future of concurrent</h2>

						<ul>
							<li><b>GPU Processing:</b> enable GPC task processing.</li>
							<li><b>Optimize network congestion:</b> enable data syncronization and optimize locality of required data.</li>
							<li><b>Sandboxing:</b> include a sandboxing feature so that tasks from different applications do not collide.</li>
							<li><b>Security:</b> add cerificates and encryption layers on the ZMQ compute channel.</li>
							<li><b>Statistics and monitoring:</b> include statistics and real-time task monitoring into the web interfaces of each node.</li>
							<li><b>Asyn I/O:</b> optmize servers to use async I/O for optimal task distribution.</li>
							<li><b>Multi-master:</b> implement a multi-master environment using a DHT and a NCS (Network Coordinate System).</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Samples</h2>

						<p>
						</p>
					</section>

					<section>
						<h2>MD5 Hash Reverse</h2>
					</section>

					<section>
						<h2>Mandlebrot Set</h2>
					</section>

					<section>
						<h2>DNA Curve Analysis</h2>
					</section>

					<section>
						<h2>Benchmark example</h2>
					</section>
				</section>

				<section>
					<section>
						<h2>Conclusion</h2>
					</section>

					<section>
						<h2>Which type of concurrent tasks are perfect for Concurrent</h2>
					</section>

					<section>
						<h2>Amdahls Law</h2>
					</section>
				</section>

				<section>
					<h2>Stellar Links</h2>
					<ul>
						<li><a href="https://github.com/moritz-wundke/Concurrent">Source code on GitHub</a></li>
						<li><a href="http://moritz-wundke.github.io/Concurrent/">Project page</a></li>
						<li><a href="http://moritz-wundke.github.io/Concurrent/API/">API Documentation</a></li>
						<li><a href="http://moritzwundke.com/uoc/tfm/video/TFM_final2.mp4">Video presentation</a></li>
					</ul>
				</section>

				<section>
					<h1>THE END</h1>
					<h3>BY Moritz Wundke / <a href="http://moritz-wundke.github.io">moritzwundke.com</a></h3>
					<small>Build with <a href="https://github.com/hakimel/reveal.js">reveal.js</a></small>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
			//Reveal.configure({ slideNumber: true });

		</script>

	</body>
</html>
