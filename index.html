<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640" />

    <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
    <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>Concurrent by moritz-wundke</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/moritz-wundke/Concurrent">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>Concurrent</h1>
            <h2>Distributed task system based on ZeroMQ and a trac [by Edgewall] like component architecture</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/moritz-wundke/Concurrent/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/moritz-wundke/Concurrent/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h1>
<a name="overview" class="anchor" href="#overview"><span class="octicon octicon-link"></span></a>Overview</h1>

<p>Concurrent aims to be a different type of task distribution system compared to what MPI like system do. It adds a simple but powerful application abstraction layer to distribute the logic of an entire application onto a swarm of clusters holding similarities with volunteer computing systems.</p>

<p>Traditional task distributed systems will just perform simple tasks onto the distributed system and wait for results. Concurrent goes one step further by letting the tasks and the application decide what to do. The programming paradigm is then totally async without any waits for results and based on notifications once a computation has been performed.</p>

<h1>
<a name="slides" class="anchor" href="#slides"><span class="octicon octicon-link"></span></a>Slides</h1>

<p>For a quick introduction about the framework have a peek onto the <a href="slides/">project slides</a> covering most of the framework current state and future.</p>

<h1>
<a name="api" class="anchor" href="#api"><span class="octicon octicon-link"></span></a>API</h1>

<p>Concurrent comes with a simple and extendable API, the component system makes it easy to create new schedule strategies and managers. Nearly all functionality is plugable to tweak and adapt the framework for your needs.</p>

<p>For more information about the inner grains refer to the <a href="API/">API documentation</a>.</p>

<h1>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h1>

<p>To show how to use Concurrent for your own tasks we will create a simple <em>hello world</em> application that just computes the string on the system and returns it to our application.</p>

<p>For this example we will create two classes, one which actually gets executed on the distributed system <code>class SimpleTask(Task):</code> and our application which interacts with the system and controls the task flow <code>class SimpleConcurrentApp(ApplicationNode)</code>. Our task class just gets executed on an arbitrary processes within the system while our application is what is getting executed on the client side creating the task, sending it to the framework and waiting for its completion.</p>

<p>The application itself is executed from a sandbox like environment enabling us to configure its behavior and monitor the application easily.</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">concurrent.framework.nodes.applicationnode</span> <span class="kn">import</span> <span class="n">ApplicationNode</span>
<span class="kn">from</span> <span class="nn">concurrent.core.application.api</span> <span class="kn">import</span> <span class="n">IApp</span>
<span class="kn">from</span> <span class="nn">concurrent.core.components.component</span> <span class="kn">import</span> <span class="n">implements</span>
<span class="kn">from</span> <span class="nn">concurrent.core.async.task</span> <span class="kn">import</span> <span class="n">Task</span>

<span class="k">class</span> <span class="nc">SimpleTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">client_id</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Just create a task specifying only a client_id, this</span>
<span class="sd">        will tell Concurrent to only process the task and</span>
<span class="sd">        send the results back</span>
<span class="sd">        """</span>
        <span class="n">Task</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">client_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Method gets called on an arbitrary slave to perform</span>
<span class="sd">        the computation</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="s">"Hello World"</span>

    <span class="k">def</span> <span class="nf">finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Once the task is finished. Called on the MasterNode</span>
<span class="sd">        within the main thread once the node has recovered</span>
<span class="sd">        the result data.</span>
<span class="sd">        """</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Hey I'm done!"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SimpleConcurrentApp</span><span class="p">(</span><span class="n">ApplicationNode</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Just a simple application showing how to send tasks to</span>
<span class="sd">    be processed using Concurrent</span>
<span class="sd">    """</span>
    <span class="n">implements</span><span class="p">(</span><span class="n">IApp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_task_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Called from the base class when we are connected </span>
<span class="sd">        to a MasterNode and we are able to send computation </span>
<span class="sd">        tasks over</span>
<span class="sd">        """</span>
        <span class="c"># We return none for the simple example, to check </span>
        <span class="c"># more advanced samples please check the samples </span>
        <span class="c"># source code</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">start_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Called when the app is not using a ITaskSystem and</span>
<span class="sd">        will instead just add tasks and will take care of</span>
<span class="sd">        the task flow itself</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Starting computation"</span><span class="p">)</span>

        <span class="c"># Create a task and send it to the system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push_task</span><span class="p">(</span>
            <span class="n">SimpleTask</span><span class="p">(</span><span class="s">"my_task"</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id_str</span><span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Called when a task has been done</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c"># shutdown</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_main_loop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push_task_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        We just add a Task to the computation framework</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Task send to computation "</span> \
            <span class="s">"framework"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">push_task_failed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        We failed to add a Task to the computation</span>
<span class="sd">        framework</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Failed to send task send to "</span> \
            <span class="s">"computation framework"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">push_tasks_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        We just add a set of Tasks to the computation</span>
<span class="sd">        framework</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Tasks send to computation "</span> \ 
            <span class="s">"framework"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">push_tasks_failed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        We failed to add a set of Tasks to the computation</span>
<span class="sd">        framework</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Failed to send tasks send to "</span> \
            <span class="s">"computation framework"</span><span class="p">)</span>
</pre></div>

<h1>
<a name="install" class="anchor" href="#install"><span class="octicon octicon-link"></span></a>Install</h1>

<p>The easiest way to install concurrent is to download it's source package and just install it using pythons disctools:</p>

<pre><code>python setup.py build_ext
python setup.py install
</code></pre>

<p>Make sure to have the python development headers installed, you also require a valid C compiler.</p>

<h1>
<a name="releases" class="anchor" href="#releases"><span class="octicon octicon-link"></span></a>Releases</h1>

<p>The project is still in its alpha state and so use in production is still not recommended. The project follows the <a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> branching pattern.</p>

<h2>
<a name="alpha-012" class="anchor" href="#alpha-012"><span class="octicon octicon-link"></span></a>Alpha 0.1.2</h2>

<p>Adds some minor bug fixes and optimizations to the Mandlebrot sample. Sockets are all non-blocking now.</p>

<h2>
<a name="alpha-011" class="anchor" href="#alpha-011"><span class="octicon octicon-link"></span></a>Alpha 0.1.1</h2>

<p>First alpha release, samples are working and the system is reasonably stable.</p>

<h3>
<a name="features" class="anchor" href="#features"><span class="octicon octicon-link"></span></a>Features</h3>

<ul>
<li>ZeroMQ compute channel (no plain TCP sockets, while they are still in there)</li>
<li>Sending work and polling work patterns</li>
<li>Statistics system for all sybsystems</li>
<li>Sandbox environments</li>
<li>JSON-RPC API and web interface</li>
<li>Fault tolerance (client is notified on error)</li>
</ul><h2>
<a name="develop" class="anchor" href="#develop"><span class="octicon octicon-link"></span></a>develop</h2>

<p>The develop branch features the most recent and unstable work. It may not even compile. </p>

<h2>
<a name="master" class="anchor" href="#master"><span class="octicon octicon-link"></span></a>master</h2>

<p>The master branch is pointing always to the most stable release, in our case this is Alpha 0.1.2</p>

<h1>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h1>

<p>MIT</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/moritz-wundke">moritz-wundke</a> can be found on <a href="https://github.com/moritz-wundke/Concurrent">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

    
  </body>
</html>
