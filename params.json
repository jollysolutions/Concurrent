{"name":"Concurrent","tagline":"Distributed task system based on ZeroMQ and a trac [by Edgewall] like component architecture","body":"# Overview #\r\nConcurrent aims to be a different type of task distribution system compared to what MPI like system do. It adds a simple but powerful application abstraction layer to distribute the logic of an entire application onto a swarm of clusters holding similarities with volunteer computing systems.\r\n\r\nTraditional task distributed systems will just perform simple tasks onto the distributed system and wait for results. Concurrent goes one step further by letting the tasks and the application decide what to do. The programming paradigm is then totally async without any waits for results and based on notifications once a computation has been performed.\r\n\r\n# API #\r\n\r\nConcurrent comes with a simple and extendable API, the component system makes it easy to create new schedule strategies and managers. Nearly all functionality is plugable to tweak and adapt the framework for your needs.\r\n\r\nFor more information about the inner grains refer to the [API documentation](/Concurrent/API/).\r\n\r\n# Usage #\r\n\r\nTo show how to use Concurrent for your own tasks we will create a simple _hello world_ application that just computes the string on the system and returns it to our application.\r\n\r\nFor this example we will create two classes, one which actually gets executed on the distributed system `class SimpleTask(Task):` and our application which interacts with the system and controls the task flow `class SimpleConcurrentApp(ApplicationNode)`. Our task class just gets executed on an abitrary processes within the system while our application is what is getting executed on the client side creating the task, sending it to the framework and waiting for its completion.\r\n\r\n```python\r\nfrom concurrent.framework.nodes.applicationnode import ApplicationNode\r\nfrom concurrent.core.application.api import IApp\r\nfrom concurrent.core.components.component import implements\r\nfrom concurrent.core.async.task import Task\r\n\r\nclass SimpleTask(Task):\r\n    def __init__(self, name, client_id):\r\n        \"\"\"\r\n        Just create a task specifying only a client_id, this\r\n        will tell Concurrent to only process the task and\r\n        send the results back\r\n        \"\"\"\r\n        Task.__init__(self, name, None, client_id)\r\n\r\n    def __call__(self):\r\n        \"\"\"\r\n        Method gets called on an arbitrary slave to perform\r\n        the computation\r\n        \"\"\"\r\n        return \"Hello World\"\r\n\r\n    def finished(self, result, error):\r\n        \"\"\"\r\n        Once the task is finished. Called on the MasterNode\r\n        within the main thread once the node has recovered\r\n        the result data.\r\n        \"\"\"\r\n        print(\"Hey I'm done!\")\r\n\r\nclass SimpleConcurrentApp(ApplicationNode):\r\n    \"\"\"\r\n    Just a simple application showing how to send tasks to\r\n    be processed using Concurrent\r\n    \"\"\"\r\n    implements(IApp)\r\n\r\n    def get_task_system(self):\r\n        \"\"\"\r\n        Called from the base class when we are connected \r\n        to a MasterNode and we are able to send computation \r\n        tasks over\r\n        \"\"\"\r\n        # We return none for the simple example, to check \r\n        # more advanced samples please check the samples \r\n        # source code\r\n        return None\r\n\r\n    def start_processing(self):\r\n        \"\"\"\r\n        Called when the app is not using a ITaskSystem and\r\n        will instead just add tasks and will take care of\r\n        the task flow itself\r\n        \"\"\"\r\n        self.log.info(\"Starting computation\")\r\n\r\n        # Create a task and send it to the system\r\n        self.push_task(\r\n            SimpleTask(\"my_task\",self.node_id_str) )\r\n\r\n    def task_finished(self, task, result, error):\r\n        \"\"\"\r\n        Called when a task has been done\r\n        \"\"\"\r\n        self.log.info(result)\r\n\r\n        # shutdown\r\n        self.shutdown_main_loop()\r\n\r\n    def push_task_response(self, result):\r\n        \"\"\"\r\n        We just add a Task to the computation framework\r\n        \"\"\"\r\n        self.log.info(\"Task send to computation \" \\\r\n            \"framework\")\r\n    \r\n    def push_task_failed(self, result):\r\n        \"\"\"\r\n        We failed to add a Task to the computation\r\n        framework\r\n        \"\"\"\r\n        self.log.info(\"Failed to send task send to \" \\\r\n            \"computation framework\")\r\n    \r\n    def push_tasks_response(self, result):\r\n        \"\"\"\r\n        We just add a set of Tasks to the computation\r\n        framework\r\n        \"\"\"\r\n        self.log.info(\"Tasks send to computation \" \\ \r\n            \"framework\")\r\n    \r\n    def push_tasks_failed(self, result):\r\n        \"\"\"\r\n        We failed to add a set of Tasks to the computation\r\n        framework\r\n        \"\"\"\r\n        self.log.info(\"Failed to send tasks send to \" \\\r\n            \"computation framework\")\r\n```\r\n\r\n# Install #\r\nThe easiest way to install concurrent is to download it's source package and just install it using pythons disctools:\r\n\r\n    python setup.py build_ext\r\n    python setup.py install\r\n\r\nMake sure to have the python development headers installed, you also require a valid C compiler.\r\n\r\n# License #\r\n\r\nMIT","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}